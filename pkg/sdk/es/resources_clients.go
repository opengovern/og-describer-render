// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	render "github.com/opengovern/og-describer-render/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: Project =============================

type Project struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     render.ProjectDescription `json:"Description"`
	Metadata        render.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type ProjectHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Project       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ProjectHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ProjectHit      `json:"hits"`
}

type ProjectSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ProjectHits `json:"hits"`
}

type ProjectPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewProjectPaginator(filters []essdk.BoolFilter, limit *int64) (ProjectPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_project", filters, limit)
	if err != nil {
		return ProjectPaginator{}, err
	}

	p := ProjectPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ProjectPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ProjectPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ProjectPaginator) NextPage(ctx context.Context) ([]Project, error) {
	var response ProjectSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Project
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listProjectFilters = map[string]string{
	"createdAt":      "Description.CreatedAt",
	"environmentIds": "Description.EnvironmentIDs",
	"id":             "Description.ID",
	"name":           "Description.Name",
	"owner":          "Description.Owner",
	"updatedAt":      "Description.UpdatedAt",
}

func ListProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListProject")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, listProjectFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListProject NewProjectPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListProject paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getProjectFilters = map[string]string{
	"createdAt":      "Description.CreatedAt",
	"environmentIds": "Description.EnvironmentIDs",
	"id":             "Description.ID",
	"name":           "Description.Name",
	"owner":          "Description.Owner",
	"updatedAt":      "Description.UpdatedAt",
}

func GetProject(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetProject")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewProjectPaginator(essdk.BuildFilter(ctx, d.QueryContext, getProjectFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Project =============================

// ==========================  START: Environment =============================

type Environment struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     render.EnvironmentDescription `json:"Description"`
	Metadata        render.Metadata               `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type EnvironmentHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Environment   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EnvironmentHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EnvironmentHit  `json:"hits"`
}

type EnvironmentSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  EnvironmentHits `json:"hits"`
}

type EnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (EnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_environment", filters, limit)
	if err != nil {
		return EnvironmentPaginator{}, err
	}

	p := EnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EnvironmentPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EnvironmentPaginator) NextPage(ctx context.Context) ([]Environment, error) {
	var response EnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Environment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEnvironmentFilters = map[string]string{
	"databasesIds":    "Description.DatabasesIDs",
	"envGroupIds":     "Description.EnvGroupIDs",
	"id":              "Description.ID",
	"name":            "Description.Name",
	"projectId":       "Description.ProjectID",
	"protectedStatus": "Description.ProtectedStatus",
	"redisIds":        "Description.RedisIDs",
	"serviceIds":      "Description.ServiceIDs",
}

func ListEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEnvironment")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEnvironmentFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvironment NewEnvironmentPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEnvironment paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEnvironmentFilters = map[string]string{
	"databasesIds":    "Description.DatabasesIDs",
	"envGroupIds":     "Description.EnvGroupIDs",
	"id":              "Description.ID",
	"name":            "Description.Name",
	"projectId":       "Description.ProjectID",
	"protectedStatus": "Description.ProtectedStatus",
	"redisIds":        "Description.RedisIDs",
	"serviceIds":      "Description.ServiceIDs",
}

func GetEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEnvironment")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEnvironmentPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEnvironmentFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Environment =============================

// ==========================  START: Postgres =============================

type Postgres struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     render.PostgresDescription `json:"Description"`
	Metadata        render.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type PostgresHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Postgres      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PostgresHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PostgresHit     `json:"hits"`
}

type PostgresSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  PostgresHits `json:"hits"`
}

type PostgresPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPostgresPaginator(filters []essdk.BoolFilter, limit *int64) (PostgresPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_postgresinstance", filters, limit)
	if err != nil {
		return PostgresPaginator{}, err
	}

	p := PostgresPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PostgresPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PostgresPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PostgresPaginator) NextPage(ctx context.Context) ([]Postgres, error) {
	var response PostgresSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Postgres
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresFilters = map[string]string{
	"createdAt":               "Description.CreatedAt",
	"dashboardUrl":            "Description.DashboardURL",
	"databaseName":            "Description.DatabaseName",
	"databaseUser":            "Description.DatabaseUser",
	"diskSizeGB":              "Description.DiskSizeGB",
	"environmentId":           "Description.EnvironmentID",
	"expiresAt":               "Description.ExpiresAt",
	"highAvailabilityEnabled": "Description.HighAvailabilityEnabled",
	"id":                      "Description.ID",
	"ipAllowList":             "Description.IPAllowList",
	"name":                    "Description.Name",
	"owner":                   "Description.Owner",
	"plan":                    "Description.Plan",
	"primaryPostgresID":       "Description.PrimaryPostgresID",
	"readReplicas":            "Description.ReadReplicas",
	"region":                  "Description.Region",
	"role":                    "Description.Role",
	"status":                  "Description.Status",
	"suspended":               "Description.Suspended",
	"suspenders":              "Description.Suspenders",
	"updatedAt":               "Description.UpdatedAt",
	"version":                 "Description.Version",
}

func ListPostgres(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgres")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPostgresPaginator(essdk.BuildFilter(ctx, d.QueryContext, listPostgresFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPostgres NewPostgresPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPostgres paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPostgresFilters = map[string]string{
	"createdAt":               "Description.CreatedAt",
	"dashboardUrl":            "Description.DashboardURL",
	"databaseName":            "Description.DatabaseName",
	"databaseUser":            "Description.DatabaseUser",
	"diskSizeGB":              "Description.DiskSizeGB",
	"environmentId":           "Description.EnvironmentID",
	"expiresAt":               "Description.ExpiresAt",
	"highAvailabilityEnabled": "Description.HighAvailabilityEnabled",
	"id":                      "Description.ID",
	"ipAllowList":             "Description.IPAllowList",
	"name":                    "Description.Name",
	"owner":                   "Description.Owner",
	"plan":                    "Description.Plan",
	"primaryPostgresID":       "Description.PrimaryPostgresID",
	"readReplicas":            "Description.ReadReplicas",
	"region":                  "Description.Region",
	"role":                    "Description.Role",
	"status":                  "Description.Status",
	"suspended":               "Description.Suspended",
	"suspenders":              "Description.Suspenders",
	"updatedAt":               "Description.UpdatedAt",
	"version":                 "Description.Version",
}

func GetPostgres(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgres")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPostgresPaginator(essdk.BuildFilter(ctx, d.QueryContext, getPostgresFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Postgres =============================

// ==========================  START: Service =============================

type Service struct {
	ResourceID      string                    `json:"resource_id"`
	PlatformID      string                    `json:"platform_id"`
	Description     render.ServiceDescription `json:"Description"`
	Metadata        render.Metadata           `json:"metadata"`
	DescribedBy     string                    `json:"described_by"`
	ResourceType    string                    `json:"resource_type"`
	IntegrationType string                    `json:"integration_type"`
	IntegrationID   string                    `json:"integration_id"`
}

type ServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Service       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ServiceHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ServiceHit      `json:"hits"`
}

type ServiceSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  ServiceHits `json:"hits"`
}

type ServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServicePaginator(filters []essdk.BoolFilter, limit *int64) (ServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_service", filters, limit)
	if err != nil {
		return ServicePaginator{}, err
	}

	p := ServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServicePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ServicePaginator) NextPage(ctx context.Context) ([]Service, error) {
	var response ServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Service
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceFilters = map[string]string{
	"autoDeploy":         "Description.AutoDeploy",
	"branch":             "Description.Branch",
	"buildFilter":        "Description.BuildFilter",
	"createdAt":          "Description.CreatedAt",
	"dashboardUrl":       "Description.DashboardURL",
	"environmentId":      "Description.EnvironmentID",
	"id":                 "Description.ID",
	"imagePath":          "Description.ImagePath",
	"name":               "Description.Name",
	"notifyOnFail":       "Description.NotifyOnFail",
	"ownerId":            "Description.OwnerID",
	"registryCredential": "Description.RegistryCredential",
	"repo":               "Description.Repo",
	"rootDir":            "Description.RootDir",
	"serviceDetails":     "Description.ServiceDetails",
	"slug":               "Description.Slug",
	"suspended":          "Description.Suspended",
	"suspenders":         "Description.Suspenders",
	"type":               "Description.Type",
	"updatedAt":          "Description.UpdatedAt",
}

func ListService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListService")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListService NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListService NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListService GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListService GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListService GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, listServiceFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListService NewServicePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListService paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getServiceFilters = map[string]string{
	"autoDeploy":         "Description.AutoDeploy",
	"branch":             "Description.Branch",
	"buildFilter":        "Description.BuildFilter",
	"createdAt":          "Description.CreatedAt",
	"dashboardUrl":       "Description.DashboardURL",
	"environmentId":      "Description.EnvironmentID",
	"id":                 "Description.ID",
	"imagePath":          "Description.ImagePath",
	"name":               "Description.Name",
	"notifyOnFail":       "Description.NotifyOnFail",
	"ownerId":            "Description.OwnerID",
	"registryCredential": "Description.RegistryCredential",
	"repo":               "Description.Repo",
	"rootDir":            "Description.RootDir",
	"serviceDetails":     "Description.ServiceDetails",
	"slug":               "Description.Slug",
	"suspended":          "Description.Suspended",
	"suspenders":         "Description.Suspenders",
	"type":               "Description.Type",
	"updatedAt":          "Description.UpdatedAt",
}

func GetService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetService")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewServicePaginator(essdk.BuildFilter(ctx, d.QueryContext, getServiceFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Service =============================

// ==========================  START: Job =============================

type Job struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     render.JobDescription `json:"Description"`
	Metadata        render.Metadata       `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type JobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Job           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type JobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []JobHit          `json:"hits"`
}

type JobSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  JobHits `json:"hits"`
}

type JobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewJobPaginator(filters []essdk.BoolFilter, limit *int64) (JobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_job", filters, limit)
	if err != nil {
		return JobPaginator{}, err
	}

	p := JobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p JobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p JobPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p JobPaginator) NextPage(ctx context.Context) ([]Job, error) {
	var response JobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Job
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listJobFilters = map[string]string{
	"createdAt":    "Description.CreatedAt",
	"finishedAt":   "Description.FinishedAt",
	"id":           "Description.ID",
	"planId":       "Description.PlanID",
	"serviceId":    "Description.ServiceID",
	"startCommand": "Description.StartCommand",
	"startedAt":    "Description.StartedAt",
	"status":       "Description.Status",
}

func ListJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListJob")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, listJobFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListJob NewJobPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListJob paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getJobFilters = map[string]string{
	"createdAt":    "Description.CreatedAt",
	"finishedAt":   "Description.FinishedAt",
	"id":           "Description.ID",
	"planId":       "Description.PlanID",
	"serviceId":    "Description.ServiceID",
	"startCommand": "Description.StartCommand",
	"startedAt":    "Description.StartedAt",
	"status":       "Description.Status",
}

func GetJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetJob")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewJobPaginator(essdk.BuildFilter(ctx, d.QueryContext, getJobFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Job =============================

// ==========================  START: Disk =============================

type Disk struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     render.DiskDescription `json:"Description"`
	Metadata        render.Metadata        `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type DiskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Disk          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DiskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DiskHit         `json:"hits"`
}

type DiskSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  DiskHits `json:"hits"`
}

type DiskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDiskPaginator(filters []essdk.BoolFilter, limit *int64) (DiskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_disk", filters, limit)
	if err != nil {
		return DiskPaginator{}, err
	}

	p := DiskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DiskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DiskPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DiskPaginator) NextPage(ctx context.Context) ([]Disk, error) {
	var response DiskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Disk
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDiskFilters = map[string]string{
	"createdAt": "Description.CreatedAt",
	"id":        "Description.ID",
	"mountPath": "Description.MountPath",
	"name":      "Description.Name",
	"serviceId": "Description.ServiceID",
	"sizeGB":    "Description.SizeGB",
	"updatedAt": "Description.UpdatedAt",
}

func ListDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDisk")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDiskPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDiskFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDisk NewDiskPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDisk paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDiskFilters = map[string]string{
	"createdAt": "Description.CreatedAt",
	"id":        "Description.ID",
	"mountPath": "Description.MountPath",
	"name":      "Description.Name",
	"serviceId": "Description.ServiceID",
	"sizeGB":    "Description.SizeGB",
	"updatedAt": "Description.UpdatedAt",
}

func GetDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDisk")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDiskPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDiskFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Disk =============================

// ==========================  START: Deploy =============================

type Deploy struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     render.DeployDescription `json:"Description"`
	Metadata        render.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type DeployHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Deploy        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DeployHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DeployHit       `json:"hits"`
}

type DeploySearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  DeployHits `json:"hits"`
}

type DeployPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDeployPaginator(filters []essdk.BoolFilter, limit *int64) (DeployPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_deploy", filters, limit)
	if err != nil {
		return DeployPaginator{}, err
	}

	p := DeployPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DeployPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DeployPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DeployPaginator) NextPage(ctx context.Context) ([]Deploy, error) {
	var response DeploySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Deploy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDeployFilters = map[string]string{
	"commit":     "Description.Commit",
	"createdAt":  "Description.CreatedAt",
	"finishedAt": "Description.FinishedAt",
	"id":         "Description.ID",
	"image":      "Description.Image",
	"status":     "Description.Status",
	"trigger":    "Description.Trigger",
	"updatedAt":  "Description.UpdatedAt",
}

func ListDeploy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDeploy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDeployPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDeployFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDeploy NewDeployPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDeploy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDeployFilters = map[string]string{
	"commit":     "Description.Commit",
	"createdAt":  "Description.CreatedAt",
	"finishedAt": "Description.FinishedAt",
	"id":         "Description.ID",
	"image":      "Description.Image",
	"status":     "Description.Status",
	"trigger":    "Description.Trigger",
	"updatedAt":  "Description.UpdatedAt",
}

func GetDeploy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDeploy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDeployPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDeployFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Deploy =============================

// ==========================  START: Blueprint =============================

type Blueprint struct {
	ResourceID      string                      `json:"resource_id"`
	PlatformID      string                      `json:"platform_id"`
	Description     render.BlueprintDescription `json:"Description"`
	Metadata        render.Metadata             `json:"metadata"`
	DescribedBy     string                      `json:"described_by"`
	ResourceType    string                      `json:"resource_type"`
	IntegrationType string                      `json:"integration_type"`
	IntegrationID   string                      `json:"integration_id"`
}

type BlueprintHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Blueprint     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BlueprintHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BlueprintHit    `json:"hits"`
}

type BlueprintSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  BlueprintHits `json:"hits"`
}

type BlueprintPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBlueprintPaginator(filters []essdk.BoolFilter, limit *int64) (BlueprintPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_blueprint", filters, limit)
	if err != nil {
		return BlueprintPaginator{}, err
	}

	p := BlueprintPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BlueprintPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BlueprintPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p BlueprintPaginator) NextPage(ctx context.Context) ([]Blueprint, error) {
	var response BlueprintSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Blueprint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBlueprintFilters = map[string]string{
	"autoSync": "Description.AutoSync",
	"branch":   "Description.Branch",
	"id":       "Description.ID",
	"lastSync": "Description.LastSync",
	"name":     "Description.Name",
	"repo":     "Description.Repo",
	"status":   "Description.Status",
}

func ListBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBlueprint")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(ctx, d.QueryContext, listBlueprintFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListBlueprint NewBlueprintPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListBlueprint paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getBlueprintFilters = map[string]string{
	"autoSync": "Description.AutoSync",
	"branch":   "Description.Branch",
	"id":       "Description.ID",
	"lastSync": "Description.LastSync",
	"name":     "Description.Name",
	"repo":     "Description.Repo",
	"status":   "Description.Status",
}

func GetBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBlueprint")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(ctx, d.QueryContext, getBlueprintFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Blueprint =============================

// ==========================  START: EnvGroup =============================

type EnvGroup struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     render.EnvGroupDescription `json:"Description"`
	Metadata        render.Metadata            `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type EnvGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  EnvGroup      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type EnvGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []EnvGroupHit     `json:"hits"`
}

type EnvGroupSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  EnvGroupHits `json:"hits"`
}

type EnvGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEnvGroupPaginator(filters []essdk.BoolFilter, limit *int64) (EnvGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_envgroup", filters, limit)
	if err != nil {
		return EnvGroupPaginator{}, err
	}

	p := EnvGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EnvGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EnvGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p EnvGroupPaginator) NextPage(ctx context.Context) ([]EnvGroup, error) {
	var response EnvGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EnvGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEnvGroupFilters = map[string]string{
	"createdAt":     "Description.CreatedAt",
	"environmentId": "Description.EnvironmentID",
	"id":            "Description.ID",
	"name":          "Description.Name",
	"ownerId":       "Description.OwnerID",
	"serviceLinks":  "Description.ServiceLinks",
	"updatedAt":     "Description.UpdatedAt",
}

func ListEnvGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEnvGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewEnvGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listEnvGroupFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListEnvGroup NewEnvGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListEnvGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getEnvGroupFilters = map[string]string{
	"createdAt":     "Description.CreatedAt",
	"environmentId": "Description.EnvironmentID",
	"id":            "Description.ID",
	"name":          "Description.Name",
	"ownerId":       "Description.OwnerID",
	"serviceLinks":  "Description.ServiceLinks",
	"updatedAt":     "Description.UpdatedAt",
}

func GetEnvGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEnvGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewEnvGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getEnvGroupFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: EnvGroup =============================

// ==========================  START: Header =============================

type Header struct {
	ResourceID      string                   `json:"resource_id"`
	PlatformID      string                   `json:"platform_id"`
	Description     render.HeaderDescription `json:"Description"`
	Metadata        render.Metadata          `json:"metadata"`
	DescribedBy     string                   `json:"described_by"`
	ResourceType    string                   `json:"resource_type"`
	IntegrationType string                   `json:"integration_type"`
	IntegrationID   string                   `json:"integration_id"`
}

type HeaderHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Header        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HeaderHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []HeaderHit       `json:"hits"`
}

type HeaderSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  HeaderHits `json:"hits"`
}

type HeaderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHeaderPaginator(filters []essdk.BoolFilter, limit *int64) (HeaderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_header", filters, limit)
	if err != nil {
		return HeaderPaginator{}, err
	}

	p := HeaderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HeaderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HeaderPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p HeaderPaginator) NextPage(ctx context.Context) ([]Header, error) {
	var response HeaderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Header
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHeaderFilters = map[string]string{
	"id":    "Description.ID",
	"name":  "Description.Name",
	"path":  "Description.Path",
	"value": "Description.Value",
}

func ListHeader(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHeader")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewHeaderPaginator(essdk.BuildFilter(ctx, d.QueryContext, listHeaderFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListHeader NewHeaderPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListHeader paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getHeaderFilters = map[string]string{
	"id":    "Description.ID",
	"name":  "Description.Name",
	"path":  "Description.Path",
	"value": "Description.Value",
}

func GetHeader(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHeader")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewHeaderPaginator(essdk.BuildFilter(ctx, d.QueryContext, getHeaderFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Header =============================

// ==========================  START: Route =============================

type Route struct {
	ResourceID      string                  `json:"resource_id"`
	PlatformID      string                  `json:"platform_id"`
	Description     render.RouteDescription `json:"Description"`
	Metadata        render.Metadata         `json:"metadata"`
	DescribedBy     string                  `json:"described_by"`
	ResourceType    string                  `json:"resource_type"`
	IntegrationType string                  `json:"integration_type"`
	IntegrationID   string                  `json:"integration_id"`
}

type RouteHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Route         `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RouteHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RouteHit        `json:"hits"`
}

type RouteSearchResponse struct {
	PitID string    `json:"pit_id"`
	Hits  RouteHits `json:"hits"`
}

type RoutePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoutePaginator(filters []essdk.BoolFilter, limit *int64) (RoutePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "render_route", filters, limit)
	if err != nil {
		return RoutePaginator{}, err
	}

	p := RoutePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RoutePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RoutePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p RoutePaginator) NextPage(ctx context.Context) ([]Route, error) {
	var response RouteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Route
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRouteFilters = map[string]string{
	"destination": "Description.Destination",
	"id":          "Description.ID",
	"priority":    "Description.Priority",
	"source":      "Description.Source",
	"type":        "Description.Type",
}

func ListRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoute")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, listRouteFilters, integrationID, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListRoute NewRoutePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListRoute paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getRouteFilters = map[string]string{
	"destination": "Description.Destination",
	"id":          "Description.ID",
	"priority":    "Description.Priority",
	"source":      "Description.Source",
	"type":        "Description.Type",
}

func GetRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoute")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationID, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, getRouteFilters, integrationID, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Route =============================
